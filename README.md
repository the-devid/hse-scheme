# HSE Scheme

Это интерпретатор языка программирования Scheme (диалект языка Lisp) в варианте, предложенном для реализации на курсе по продвинутому C++ на ПМИ ФКН НИУ ВШЭ (во многом аналогичному курсу ШАДа). Назовём его `hse-scheme`. На данный момент предлагается только исполнение в формате Run-Eval-Print Loop, то есть исполнение команд одна за другой в интерактивном режиме. Команды должны целиком располагаться на строке, которая будет исполняться.

## Сборка

Находясь в сборочной директории, если `path/to/dir` - путь до файла `CMakeLists.txt` из данного проекта, выполнить следующее:
```bash
cmake path/to/dir
make
```
После чего будет собран исполняемый файл `scheme_repl`.

Находясь в корне склонированного репозитория можно сделать
```bash
mkdir build && cd $_
cmake ..
make
```

## Синтаксис
Числа задаются числами, логические значения константами `#t` и `#f` (`true` и `false` соответственно). Пара задаётся как `(x . y)`. "Ничто" задаётся как `()`. Списки (proper list) - рекурсивные пары, самый правый элемент которых - ничто. Они имеют вид `(A . (B . (... . (X . ()))))`, но проще записываются как `(A B ... X)`. Список, который не оканчивается на "ничто" тоже возможен (задаётся `(A B . X)` - improper list), но в большинстве стандартных случаев неприменим.
Также есть функции, которые могут вычисляться на списках. Для этого надо в начале списка написать название функции. Стандартные операторы в большинстве случаев могут вычислять результат по множеству значений (например `(+ A B C)` вычисляется в сумму `A+B+C`, а `(< a b c d)` возвращает `#t` если `a < b < c < d`). Есть функции от пар и списков.

Выражения имеют понятия "вычислимости". Числа, логические выражения вычисляются в себя. Символы вычисляются в свои значения в рамках видимого в момент исполнения пространства имён переменных. Список вычисляется путем применения первого элемента к остальным как набору аргументов. Чтобы была возможность получить в результате вычисления любой объект, существует оператор `(quote x)` который просто возвращает свой аргумент, не вычисляя его рекурсивно. Краткая форма записи - `'x` (напрмиер `'(1 2 . 3)` вычислится в improper list из 1, 2 и 3).

Также существует оператор ветвления, который представляет собой функцию `(if condition true_branch false_branch)` или `(if condition true_branch)`, вычисляющую нужную ветку (если она есть, а её может не быть если if только с true_branch, а условие не выполняется) и возвращающую её результат.

Помимо красивых функциональных концепций `hse-scheme` поддерживает стандартные для `scheme` взаимодействующие с текущим окружением операции. Так, можно объявить переменную в текущем контексте исполнения `(define var value)`, изменить её через `(set! var new_value)`, а также можно менять элементы пары независимов через `set-car!` и `set-cdr!`. 

Наконец, есть возможность определять свои функции и лямбда-выражения, действующие как замыкание, то есть сохраняющие "указатель" на видимое при объявлении пространство имён переменных (которое затем может меняться, и функция будет "видеть" эти изменения). `(lambda (arg_1 ... arg_n) expr_1 .. expr_m)` определяет лямбда-выражение с аргументами `arg_1`, ..., `arg_n` (которые можно использовать при вычислениях внутри функции) и вычисляющее результаты выражений `expr_1`, ..., `expr_m`. При вычислении возвращается результат последнего выражения в списке. Именованную функцию можно определить через `define (func_name arg_1 ... arg_n) expr_1 ... expr_m`, или через присваивание лямбда-выражения: `(define func_name (lambda (arg_1 ... arg_n) expr_1 .. expr_m))`.  Естественно, вычисление происходит только в момент вызова функции непосредственно.
